{-# OPTIONS -fno-warn-orphans #-}
module NLP.GenI.BtypesBinary where

import Data.Binary
import NLP.GenI.Btypes
import NLP.GenI.GeniVal
import NLP.GenI.FeatureStructures
import NLP.GenI.TreeSchemata

-- auto-generated by the Data.Binary BinaryDerive tool
instance Binary NLP.GenI.TreeSchemata.Ptype where
  put Initial = putWord8 0
  put Auxiliar = putWord8 1
  put Unspecified = putWord8 2
  get = do
    tag_ <- getWord8
    case tag_ of
      0 -> return Initial
      1 -> return Auxiliar
      2 -> return Unspecified
      _ -> fail "no parse"

instance Binary NLP.GenI.GeniVal.GeniVal where
  put (GeniVal a b) = put a >> put b
  get = get >>= \a -> get >>= \b -> return (GeniVal a b)

instance Binary gv => Binary (NLP.GenI.TreeSchemata.GNode gv) where
  put (GN a b c d e f g h) = put a >> put b >> put c >> put d >> put e >> put f >> put g >> put h
  get = get >>= \a -> get >>= \b -> get >>= \c -> get >>= \d -> get >>= \e -> get >>= \f -> get >>= \g -> get >>= \h -> return (GN a b c d e f g h)

instance Binary NLP.GenI.TreeSchemata.GType where
  put Subs = putWord8 0
  put Foot = putWord8 1
  put Lex = putWord8 2
  put Other = putWord8 3
  get = do
    tag_ <- getWord8
    case tag_ of
      0 -> return Subs
      1 -> return Foot
      2 -> return Lex
      3 -> return Other
      _ -> fail "no parse"

instance (Binary a) => Binary (NLP.GenI.TreeSchemata.Ttree a) where
  put (TT a b c d e f g h) = put a >> put b >> put c >> put d >> put e >> put f >> put g >> put h
  get = get >>= \a -> get >>= \b -> get >>= \c -> get >>= \d -> get >>= \e -> get >>= \f -> get >>= \g -> get >>= \h -> return (TT a b c d e f g h)


instance Binary a => Binary (NLP.GenI.FeatureStructures.AvPair a) where
  put (AvPair a b)  = put a >> put b
  get = get >>= \a -> get >>= \b -> return (AvPair a b)

instance Binary NLP.GenI.Btypes.ILexEntry where
  put (ILE a b c d e f g h i) = put a >> put b >> put c >> put d >> put e >> put f >> put g >> put h >> put i
  get = get >>= \a -> get >>= \b -> get >>= \c -> get >>= \d -> get >>= \e -> get >>= \f -> get >>= \g -> get >>= \h -> get >>= \i -> return (ILE a b c d e f g h i)


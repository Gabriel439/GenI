<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Tree assembly</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <h1>Tree assembly</h1>
        <div id="navigation">
            <a href="../">home</a>
            <a href="../about.html">about</a>
            <a href="../manual">manual</a>
        </div>

        <p>After the lexical selection phase, we move into tree assembly. The input to this phase is the semantic formula we wish to realise, and the set of lexically selected elementary trees. Our objective is to find every derived tree that can be built from these parts and which is (i) syntactically complete, meaning it has no empty substitution sites and (ii) semantically complete, meaning that its semantics exactly matches the input semantics. Ultimately, the goal of realisation is to produce a set of strings, but this basically consists of concatenating the leaves of each derived tree.</p>
<p>To cope with the problem of intersective modifiers, the algorithm uses the delayed modification strategy of (TODO: citation) Realisation occurs in two chart generation phases, a substitution phase (where only TAG substitutions are performed), and an adjunction phase (likewise, TAG adjunctions only). Separating forces the realiser to only insert modifiers into syntactically complete structures. It also happens to be a very natural strategy to use with TAG because adjunction and auxiliary trees are part and parcel of the formalism. This could be seen as a potential advantage for TAG as a generation formalism (TODO: citation) .</p>
<p>We can think of the two phases as two successive chart generation problems fed to a generic deductive parser. For clarity, here is a more procedural description of the algorithm. We are using agenda based control mechanism common to many chart parsing algorithms, where the <strong>agenda</strong> is a data structure for storing unprocessed intermediate results. For convenience, we introduce a new data structure, called an <strong>auxiliary agenda</strong>. The auxiliary agenda is used to set aside any syntactically complete auxiliary trees found during the first phase of realisation. It is not strictly necessary, but it saves the trouble of filtering the chart afterwards. Here are the two phases in detail:</p>
<h5 id="substitution-phase">Substitution phase</h5>
<ol style="list-style-type: decimal">
<li><p>Store the lexically selected trees in the agenda, except for auxiliary trees which are devoid of substitution nodes (put these in the auxiliary agenda).</p></li>
<li><p>Loop: Retrieve a tree from the agenda, add it to the chart and try to combine it by substitution with trees present in the chart. Add any resulting derived tree to the agenda. Stop when the agenda is empty.</p></li>
</ol>
<h5 id="adjunction-phase">Adjunction phase</h5>
<ol start="3" style="list-style-type: decimal">
<li><p>Move the chart trees to the agenda and the auxiliary agenda trees on to the chart. Discard all trees which are not syntactically complete (i.e. that still have open substitution nodes), as they will never become complete in this phase.</p></li>
<li><p>Loop: Retrieve a tree from the agenda, add it to the chart and try to combine it by adjunction with trees present in the chart. Add any resulting derived tree to the agenda. Stop when the agenda is empty.</p></li>
</ol>
<p>The inner workings of this algorithm might be better illustrated by an example or two:</p>
<h3 id="kelvin-runs-often">Kelvin runs often</h3>
<p>Let us start with a simple one. Suppose that the input semantics is <code>l0:run(r) l0:agent(r k) l0:often(r) l1:name(k Kelvin)</code>. Lexical selection gives us a set of elementary trees lexicalised with the words <em>Kelvin</em>, <em>often</em>, <em>runs</em>. The trees for <em>Kelvin</em> and <em>runs</em> are placed on the agenda, the one for <em>often</em> is placed on the auxiliary agenda.</p>
<div class="figure">
<img src="images/kelvin-runs-1.png" alt="Kelvin, often, runs" /><p class="caption">Kelvin, often, runs</p>
</div>
<p>We begin with the <strong>substitution phase</strong>, which consists of systematically exploring the possibility of combining two trees by substitution. Note that in the table below, the letters ‘k’, ‘r’ and ‘o’ stand for the elementary trees that correspond to <em>Kelvin</em>, <em>runs</em> and <em>often</em>, respectively. When the trees combine, we write, for example, ‘kr’ to mean a derived tree for <em>Kelvin runs</em>. We see that here, the tree for <em>Kelvin</em> is substituted into the one for <em>runs</em>, and the resulting derived tree for <em>Kelvin runs</em> is placed on the agenda. Trees on the agenda are processed one by one in this fashion, although in this simple example, there is only one substitution to be done. When the agenda is empty, indicating that all combinations have been tried, we prepare for the next phase.</p>
<table>
<thead>
<tr class="header">
<th align="left">Combination</th>
<th align="left">Agenda</th>
<th align="left">Chart</th>
<th align="left">AgendaA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left">k,r</td>
<td align="left"></td>
<td align="left">o</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">r,</td>
<td align="left">k</td>
<td align="left">o</td>
</tr>
<tr class="odd">
<td align="left">↓(r,k)</td>
<td align="left">kr</td>
<td align="left">r,k</td>
<td align="left">o</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="left">r,k,kr</td>
<td align="left">o</td>
</tr>
</tbody>
</table>
<p>All items containing an open substitution node are erased from the chart (here, the tree anchored by <em>runs</em>) as there is no hope that they will be made complete in this phase. The agenda is then reinitialised to the content of the chart and the chart to the content of the auxiliary agenda (here <em>often</em>). The <strong>adjunction phase</strong> proceeds much like the previous phase, except that now all possible adjunctions are performed. When the agenda is empty once more, the items in the chart whose semantics matches the input semantics are selected, and their strings printed out, yielding in this case the sentence <em>Kelvin runs often</em>.</p>
<table>
<thead>
<tr class="header">
<th align="left">Combination</th>
<th align="left">Agenda</th>
<th align="left">Chart</th>
<th align="left">Results</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left">k,kr</td>
<td align="left">o</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">kr</td>
<td align="left">o</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">*(kr,o)</td>
<td align="left">kro</td>
<td align="left">o</td>
<td align="left"><!-- * --></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="left">o</td>
<td align="left">kro</td>
</tr>
</tbody>
</table>
<p>Note that the chart never changes during the adjunction phase. This is because we do not store new items onto the chart. As each tree is removed from the agenda, either we notice that it is semantically complete and save it as a result, or we perform all adjunction operations involving (i) the tree and (ii) a tree from the chart, and put any resulting derived trees back onto the agenda. The tree itself is no longer of any use and may be discarded. We will see more implications of this below, when we have more than one auxiliary tree that can adjoin into the same node.</p>
<h3 id="kelvin-runs-often-in-colorado">Kelvin runs often in Colorado</h3>
<p>Now, a slightly more complicated example. Here, we shall see auxiliary tree with substitution nodes, as well as a lexical selection which leads to more than one result. Our new input semantics is <code>l1:name(k Kelvin) l0:often(r) l0:run(r k) l0:in(r i) l0:place(i Colorado)</code> , basically the same as before with two new literals. The lexically selected trees are the same as before plus trees for <em>in</em> and <em>Colorado</em>. The trees for <em>in</em>, <em>Colorado</em>, <em>Kelvin</em> and <em>runs</em> are placed on the agenda, whereas the tree for <em>often</em> is placed on the auxiliary agenda.</p>
<div class="figure">
<img src="images/kelvin-runs-2.png" alt="Kelvin, often, runs" /><p class="caption">Kelvin, often, runs</p>
</div>
<p>Again, the substitution phase explores all possible substitutions, of which there are two: <em>Kelvin</em> into <em>runs</em> to get <em>Kelvin runs</em>, and <em>Colorado</em> into <em>in</em> to get <em>in Colorado</em>. The case of <em>in Colorado</em> is particularly interesting because it is a syntactically complete auxiliary tree V(V*,PP(P(in),NP(Colorado))), in the sense that it has no open substitution sites. When we produce such trees, we transfer them to the auxiliary agenda, so that they can be used during the adjunction phase.</p>
<table>
<thead>
<tr class="header">
<th align="left">Combination</th>
<th align="left">Agenda</th>
<th align="left">Chart</th>
<th align="left">AgendaA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left">i,c,k,r</td>
<td align="left"></td>
<td align="left">o</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">c,k,r</td>
<td align="left">i</td>
<td align="left">o</td>
</tr>
<tr class="odd">
<td align="left">↓(i,c)</td>
<td align="left">ic,k,r</td>
<td align="left">i,c</td>
<td align="left">o</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">k,r</td>
<td align="left">i,c</td>
<td align="left">o,ic</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">r</td>
<td align="left">i,c,k</td>
<td align="left">o,ic</td>
</tr>
<tr class="even">
<td align="left">↓(r,k)</td>
<td align="left">kr</td>
<td align="left">i,c,k,r</td>
<td align="left">o,ic</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="left">i,c,k,r,kr</td>
<td align="left">o,ic</td>
</tr>
</tbody>
</table>
<p>As before, all items containing an empty substitution node are erased from the chart (here, the trees anchored by <em>runs</em> and by <em>in</em>). The agenda is then reinitialised to the content of the chart and the chart to the content of the auxiliary agenda (here <em>often</em> and <em>in Colorado</em>). The <strong>adjunction phase</strong> proceeds, performing all possible adjunctions. When the agenda is empty once more, the items in the chart whose semantics matches the input semantics are selected, and their strings printed out, yielding in this case the sentences <em>Kelvin runs often in Colorado</em> and <em>Kelvin runs in Colorado often</em>.</p>
<table>
<thead>
<tr class="header">
<th align="left">Combination</th>
<th align="left">Agenda</th>
<th align="left">Chart</th>
<th align="left">Results</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left">c,k,kr</td>
<td align="left">o, ic</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">k,kr</td>
<td align="left">o, ic</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">kr</td>
<td align="left">o, ic</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">*(kr,o), *(kr,ic)</td>
<td align="left">kro,kric</td>
<td align="left">o, ic</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">*(kro,ic)</td>
<td align="left">kroic,kric</td>
<td align="left">o, ic</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">kric</td>
<td align="left">o, ic</td>
<td align="left">kroic</td>
</tr>
<tr class="odd">
<td align="left">*(kric,o)</td>
<td align="left">krico</td>
<td align="left">o, ic</td>
<td align="left">kroic</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="left">o, ic</td>
<td align="left">kroic, krico</td>
</tr>
</tbody>
</table>
<p>Here, we get more than one result because trees can combine in different ways (we could also get more than one result if we had an ambiguous lexical selection, but this is not the case here). Note, by the way, that the combinations here are a result of embedded adjunctions and not multiple adjunctions. The fact that supports the former but not the latter is a technical detail, and affects the number of outputs it produces (allowing for multiple adjunctions introduces more output since we cannot forbid embedded adjunctions), as well as the derivation trees for the output.</p>
    </body>
</html>

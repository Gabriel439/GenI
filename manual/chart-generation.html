<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Chart generation</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <h1>Chart generation</h1>
        <div id="navigation">
            <a href="../">home</a>
            <a href="../about.html">about</a>
            <a href="../manual">manual</a>
        </div>

        <h1 id="realisation-algorithms">Realisation algorithms</h1>
<h2 id="one-phase-generation">One-phase generation</h2>
<p>This is a standard chart-and-agenda mechanism, where each iteration consists of picking an item off the agenda and combining it with elements from the chart. You most likely want to avoid this option.</p>
<h2 id="two-phase-generation">Two-phase generation</h2>
<p>Following TODO: citation , we could also separate realisation into two distinct phases. This requires that we maintain two seperate agendas and process them sequentially, one loop after the other. See {switchToAux} for details.</p>
<ul>
<li><p>If both Agenda and AuxAgenda are empty then there is nothing to do, otherwise, if Agenda is empty then we switch to the application of the Adjunction rule.</p></li>
<li><p>After the rule is applied we classify solutions into those that are complete and cover the semantics and those that don’t. The first ones are returned and added to the result, while the others are sent back to Agenda.</p></li>
<li><p>Notice that if we are applying the Substitution rule then the current agenda item is added to the chart, otherwise it is deleted.</p></li>
</ul>
<h3 id="switching-phases">Switching phases</h3>
<p>After the substitution and na-constraint phases are complete, we switch to the final adjunction phase. We do this by deleting junk from the agenda (particularly, trees with open substitution sites remaining), transfering trees from the holding pen to the chart and setting the phase to AdjunctionPhase</p>
<h3 id="completion">Completion</h3>
<h4 id="semfilter-optimisation">SemFilter Optimisation</h4>
<p>{sec:semfilter}</p>
<p>The purpose of the semantic filter optimisation is to take full advantage of Carroll’s delayed adjunction. Consider the semantics {def(m), poor(m), brokenhearted(m), man(m), def(w), woman(w), beautiful(w), heartless(w), rejects(w,m)}. At the switchToAux step, we are left with the initial trees {man}, {woman}, {the woman rejects the man}.</p>
<p>It would be nice to filter out the structures {man} and {woman} since we know that they are not going to be semantically complete even with adjunction. More precisely, on the switch to adjunction, we do the following:</p>
<ul>
<li><p>Take the union of the semantics of all auxiliary trees; which we call <span class="math"><em>ϕ</em><sup> * </sup></span></p></li>
<li><p>Delete any initial tree with semantics <span class="math"><em>ϕ</em><sup><em>s</em></sup></span> such that <span class="math"><em>ϕ</em><sup><em>s</em></sup> ∪ <em>ϕ</em><sup> * </sup></span> is not the target semantics</p></li>
</ul>
<p>In other words, we delete all initial trees that cannot produce a semantically complete result even with the help of auxiliary trees.</p>
<p>FIXME: comment 2006-04-18: sem filter each polarity path separately (this is more aggressive; it gives us much more filtering)</p>
<h2 id="operations">Operations</h2>
<p>We implement the two TAG operations, substitution and adjunction, below. These are the only two operations we have, because we’re working with a very simple builder that constructs derived trees.</p>
<h3 id="substitution">Substitution</h3>
<p>{sec:substitution} {applySubstitution} Given a SimpleItem it returns the list of all possible substitutions between it and the elements in Chart</p>
<h3 id="adjunction">Adjunction</h3>
<p>{sec:adjunction} {sec:ordered_adjunction} {sec:foot_constraint} {applyAdjunction2p} Given a SimpleItem, it returns the list of all possible adjunctions between it and the elements in Chart. The Chart contains Auxiliars, while SimpleItem is an Initial</p>
<p>Note: as of 13 april 2005 - only uses ordered adjunction as described in</p>
<p>Note that in the one-phase variant of non-adjunction, we can’t do top/bot unification on the fly, because afaik we can’t tell that a node will never be revisited. One example of this is if you try to adjoin into the root</p>
<p>The main work for adjunction is done in the helper function below (see also figure {fig:adjunction}). Auxiliary tree <code>te1</code> has a root node <code>r</code> and a foot node <code>f</code>. Main tree <code>te2</code> has an adjunction site <code>an</code>. The resulting tree <code>res</code> is a result of splicing <code>te1</code> into <code>te2</code>. We replace <code>s</code> with the nodes <code>anr</code> and <code>anf</code> (which are the results of unifying <code>an</code> with <code>r</code> and <code>f</code> respectively).</p>
<blockquote>
<blockquote>
<p><embed src="images/adjunction.pdf" /> {fig:adjunction} {iapplyAdjNode}</p>
</blockquote>
</blockquote>
<p>In addition to the trees proper, we have to consider that each tree has a list with a copy of its adjunction sites. The adjunction list of the result (<code>adjnodes res</code>) should then contain <code>adjnodes te1</code> and <code>adjnodes te2</code>, but replacing <code>r</code> and <code>an</code> with <code>anr</code>.</p>
<h3 id="helper-functions-for-operations">Helper functions for operations</h3>
<h4 id="derivation-trees">Derivation trees</h4>
<p>We make the simplifying assumption that each chart item is only used once. This is clearly wrong if we allow for items with an empty semantics, but since we do not actually allow such a thing, we’re ok.</p>
<h2 id="dispatching-new-results">Dispatching new results</h2>
<p>Dispatching is the process where new chart items are assigned to one of the trash, agenda, auxiliary agenda or chart. The item could be modified during dispatch-time; for example, we might do top/bottom unification on it. See {sec:dispatching} for more details.</p>
<h3 id="top-and-bottom-unification">Top and bottom unification</h3>
<p>During initialisation of the chart, any nodes which can never receive adjunction should be top-bottom unified to start with.</p>
<h5 id="tbunifytree">tbUnifyTree</h5>
<p>unifies the top and bottom feature structures of each node on each tree. Note: this only determines if it is possible to do so. Actually returning the results is possible and even easy (you’ll have to look back into the darcs repository and unpull the patch from 2006-05-21T15:40:51 “Remove top/bot unification standalone code.”) but since it is only used in the one-phase algorithm and for the graphical interface, I decided not to bother.</p>
<p>Our helper function corresponds to the first unification step. It is meant to be called from a fold. The node argument represents the current node being explored. The Either argument holds a list of pending substitutions and a copy of the entire tree.</p>
<p>There are two things going on in here:</p>
<ol style="list-style-type: decimal">
<li><p>check if unification is possible - first we apply the pending substitutions on the node and then we check if unification of the top and bottom feature structures of that node succeeds</p></li>
<li><p>keep track of the substitutions that need to be performed - any new substitutions that result from unification are added to the pending list</p></li>
</ol>
<p>Note that we wrap the second argument in a Maybe; this is used to indicate that if unification suceeds or fails. We also use it to prevent the function from doing any work if a unification failure from a previous call has already occured.</p>
<p>Getting this right was a big pain in the butt, so don’t go trying to simplify this over-complicated code unless you know what you’re doing.</p>
<h2 id="unpacking-the-results">Unpacking the results</h2>
<p>Unpacking the results consists of converting each result into a sentence automaton (to take care of atomic disjunction) and reading the paths of each automaton.</p>
<h3 id="sentence-automata">Sentence automata</h3>
<p>{listToSentenceAut} converts a list of GNodes into a sentence automaton. It’s a actually pretty stupid conversion in fact. We pretty much make a straight path through the automaton, with the only cleverness being that we provide a different transition for each atomic disjunction.</p>
<h2 id="partial-results">Partial results</h2>
<p>The user may ask for partial results when realisation fails. We implement this using a greedy, full-commitment algorithm. Find the discarded result that matches the largest part of the semantics and output that fragment. If there are parts of the input semantics not covered by that fragment, search for the largest chunk that covers the missing semantics. Recurse until there are no more eligible items.</p>
    </body>
</html>

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Ranking output with Optimality Theory</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <h1>Ranking output with Optimality Theory</h1>
        <div id="navigation">
            <a href="../">home</a>
            <a href="../about.html">about</a>
            <a href="../manual">manual</a>
        </div>

        <p>If your tree schemata are annotated with traces (TODO link to traces and metagrammars), you can re-use them as a basis for ranking the output produced by GenI. The basic idea is to supply a list of either positive, negative or negative conjunction constraints.</p>
<p>For users familiar with Haskell, the constraints are described with the following type:</p>
<p>Roughly speaking the more highly ranked the constraint, the greater the impact of a violation of that constraint will be. See section {sec:ranking-procedure} for more details on the ranking procedure.</p>
<h2 id="input-format">Input format</h2>
<p>Constraints are expressed in JSON as a list of {ranking levels}. A ranking level is a list of constraints that should be assigned the same rank. In lieu of a formal description, we provide an example below: {NB: Either the JSON format or the JSON parser used by GenI is strict enough to refuse initial whitespace in this file.}</p>
<pre><code>[
 [{&quot;neg-constraint&quot;: &quot;dian0Vn1dePassive&quot;},
  {&quot;pos-constraint&quot;: &quot;CanonicalSubject&quot;}],

 [{&quot;neg-conj-constraint&quot;: [&quot;InvertedNominalSubject&quot;,
                           &quot;CanonicalSententialObjectFinite&quot;]}],

 [{&quot;neg-conj-constraint&quot;: [&quot;InvertedNominalSubject&quot;,
                           &quot;UnboundedCleft&quot;]},
  {&quot;neg-constraint&quot;: &quot;CleftSubject&quot;}]
]</code></pre>
<p>This example constraints file has three ranking levels. These levels contain following constraints:</p>
<ol style="list-style-type: decimal">
<li><p>A negative constraint saying that <code>dian0Vn1dePassive</code> should not appear, and a positive one saying that <code>CanonicalSubject</code> <em>should</em> appear. These constraints appear together only because the author of the example thinks they should have the same rank, not because there is neccesarily any inherent relationship between them.</p></li>
<li><p>A single negative conjunction constraint saying that <code>InvertedNominalSubject</code> and <code>CanonicalSententialObjectFinite</code> should not appear together.</p></li>
<li><p>A negative conjunction constraint saying tat <code>InvertedNominalSubject</code> and <code>UnboundedCleft</code> should not appear together; and also a negative constraints saying that <code>CleftSubject</code> should not appear. As with the first ranking level, there is no relationship between these two constraints. We just put them on the same level to give them the same rank</p></li>
</ol>
<h2 id="ranking-procedure">Ranking procedure</h2>
<p>{sec:ranking-procedure}</p>
<p>Generation results are sorted according to their highest-ranking constraint violation (moving on to the next-highest ranking violation and so forth in case of a tie). The best result appears first.</p>
<h2 id="output-format">Output format</h2>
<p>Constraint violations can be outputted as JSON objects as the following example shows</p>
<pre><code>  { &quot;lex-item&quot;: &quot;discuter:n0Vn1pn2:Tn0Vn1pn2-5830:22&quot;,
  , &quot;rank&quot;: 6,
  , &quot;violation&quot;: {&quot;neg-constraint&quot;: &quot;passiveVerbMorphology&quot;}
  }</code></pre>
<p>Positive constraint violations are not associated with any lexical items so the lex-item field is omitted for them.</p>
    </body>
</html>
